<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>dev_log</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="dev_log_files/libs/clipboard/clipboard.min.js"></script>
<script src="dev_log_files/libs/quarto-html/quarto.js"></script>
<script src="dev_log_files/libs/quarto-html/popper.min.js"></script>
<script src="dev_log_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="dev_log_files/libs/quarto-html/anchor.min.js"></script>
<link href="dev_log_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="dev_log_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="dev_log_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="dev_log_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="dev_log_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="development-log" class="level2">
<h2 class="anchored" data-anchor-id="development-log">Development Log:</h2>
<p>2025/05/22: - <a href="https://scienceweb.whoi.edu/itp/data/">[Here]</a> contains all data needed for the project. Below is a list of dataset folders that we did not use and why:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 42%">
<col style="width: 57%">
</colgroup>
<thead>
<tr class="header">
<th>ITP System Number</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>31, 40</td>
<td>Mission in Antarctica</td>
</tr>
<tr class="even">
<td>96,106,124,133,135,137,138,139,141,142,143</td>
<td>Still active</td>
</tr>
<tr class="odd">
<td>39,45,46</td>
<td>LMP Missions (in lakes)</td>
</tr>
<tr class="even">
<td>134</td>
<td>Device not deployed yet</td>
</tr>
<tr class="odd">
<td>136, 140</td>
<td>Not been retreived yet?</td>
</tr>
<tr class="even">
<td>20, 67, 71, 44, 50, 66</td>
<td>Received no profiles due to technical difficulties</td>
</tr>
<tr class="odd">
<td>93</td>
<td>Directory error, deployed in irrelevant area</td>
</tr>
</tbody>
</table>
<ul>
<li><code>test.py</code> and <code>matlabRead.py</code> have scripts that could read from .mat files. The next step is to filter them through our requirement. The question now is whether we need to convert them into .nc or other format after filtering through them</li>
<li>Since the dataset is totally different, we might not need the itp package?? Or we can write our own package</li>
<li>We should also read through the clustering method and figure out how it works.</li>
<li><h2 id="in-the-test.py-we-might-need-to-pay-attention-to-the-data-structure-when-unpacking-the-.matfile-variables.-the-ordering-is-weird." class="anchored">in the <code>test.py</code>, we might need to pay attention to the data structure when unpacking the <code>.mat</code>file variables. the ordering is weird.</h2>
2025/05/26:</li>
<li><h2 id="the-dataset-is-done-and-need-to-be-filtered" class="anchored">the dataset is done, and need to be filtered</h2>
2025/05/27:</li>
<li>the cleaned dataset is done. There are in total of 32557 profiles, slightly less than the number of observations from 1-db measurement dataset (they have 35135 profiles)</li>
<li>There are few code pieces need to be changed to accomodate the new data format:
<ul>
<li>These code pieces need to be deleted or changed as their functioaliy is replaced by other scripts.
<ul>
<li><code>convert.py</code> deleted</li>
<li><code>filter.py</code> deleted.</li>
<li><code>read.py</code> deleted.</li>
<li><code>unpack_matlab.py</code> renamed to <code>singleProfileReader.py</code> to test new functions on single profile.</li>
</ul></li>
<li>There scripts need to be modified. Their functionality is still important.
<ul>
<li><code>helper.py</code> remained same. Will add more helper functions.</li>
<li><code>omniPlot.py</code> renamed to <code>04_Plot.py</code>, changed functionality</li>
</ul></li>
<li>These are kept unchanged for now, but maybe a better name:
<ul>
<li><code>pull.py</code> changed to <code>01_pullData.py</code></li>
<li><code>test.py</code> changed to <code>00_testField.py</code></li>
<li><code>number_check.py</code> changed to <code>03_checkData.py</code></li>
<li><code>matlabRead.py</code> changed to <code>02_cleanData.py</code></li>
</ul></li>
</ul></li>
<li><h2 id="we-need-to-look-into-the-delta-z-of-each-profile.-maybe-we-need-to-make-a-constant-resolution." class="anchored">we need to look into the delta z of each profile. Maybe we need to make a constant resolution.</h2>
2025/05/28:</li>
<li><h2 id="we-need-to-get-the-dz-values-for-each-profile-summarize-it-into-a-histogram.-this-would-be-done-in-a-new-script-called-05_analyze.py" class="anchored">We need to get the dz values for each profile, summarize it into a histogram. This would be done in a new script called <code>05_analyze.py</code></h2>
2025/05/29:</li>
<li>The histogram is out, and 0.25 grid sounds like a reasonable resolution.</li>
<li>Need to look into what had caused the drastic depth difference in the data.</li>
<li>from the experiment in testfield, the data structure is indeed weird: each measurement in one profile is not strictly arranged in time:
<ul>
<li>take <code>D:\EOAS\ITP_Data_Analysis\datasets\itp41cormat\cor1391.mat</code> for example, the first entry in its depth is 412.52 instead of 200</li>
<li>sort() does the work</li>
</ul></li>
<li>Task: refilter the dataset to get the “golden standard” data:
<ul>
<li>Profile taken in the beaufort Gyre</li>
<li><h2 id="deepest-measurement-is-taken-at-least-2m-deeper-than-where-the-aw-temperature-max-appear." class="anchored">Deepest measurement is taken at least 2m deeper than where the AW temperature max appear.</h2>
2025/05/30:</li>
</ul></li>
<li>The golden standard dataset is out: we have in total of 23366 profiles.</li>
<li>Max depth difference in range of 200 to 600 meters below the sea is 88m.</li>
<li><h2 id="most-99-of-the-abnormal-depth-difference-occurs-in-itp-41.-05_analyze.py-looks-into-the-dataset-and-would-produce-a-summary." class="anchored">Most (99%) of the abnormal depth difference occurs in ITP# 41. <code>05_analyze.py</code> looks into the dataset and would produce a summary.</h2>
2025/06/02:</li>
<li><h2 id="gridmaker.py-will-interpolate-on-a-0.25-meter-grid-and-save-everything-in-a-different-folder-called-griddata" class="anchored"><code>06_gridMaker.py</code> will interpolate on a 0.25 meter grid, and save everything in a different folder called “gridData”</h2>
2025/06/03:</li>
<li><h2 id="cleandata.py-mostly-fixed-still-need-to-find-out-a-way-to-make-it-write-into-another-folder." class="anchored"><code>02_cleanData.py</code> mostly fixed, still need to find out a way to make it write into another folder.</h2>
2025/06/04:</li>
<li><h2 id="cleandata.py-done-new-dataset-would-be-collected-and-cleaned-once-the-whoi-database-has-confirmed-that-itp93-has-profiles." class="anchored"><code>02_cleanData.py</code> done, new dataset would be collected and cleaned once the WHOI database has confirmed that ITP#93 has profiles.</h2>
2025/06/05:</li>
<li><code>03_checkData.py</code> has been deprecated.</li>
<li><h2 id="in-the-staricase-detection-algorithm-the-te_adj-and-sa_adj-were-further-converted-with-gsw-functions-do-we-really-need-that" class="anchored">In the staricase detection algorithm, the <code>te_adj</code> and <code>sa_adj</code> were further converted with gsw functions, do we really need that?</h2>
2025/06/06:</li>
<li><code>06_gridMaker</code> successfully transforms .mat into 0.25m gridded dataframe.</li>
<li>reorganized <code>05_analyze.py</code> and <code>06_gridMaker.py</code> with helper function</li>
<li><h2 id="minor-changes-made-to-makefile-02_cleandata.py-and-helper.py" class="anchored">Minor changes made to <code>Makefile</code>, <code>02_cleanData.py</code> and <code>helper.py</code></h2>
2025/06/09:</li>
<li><code>08_SOM.py</code> is on the way to implement Self-organizing Map to cluster single profile for assessing the quality of clustering</li>
<li>considering adding a function for <code>06_gridMaker.py</code> so that it also produces <code>.mat</code> format files for easier matlab process. Note: it does not convert to v7.3 MATLAB files.</li>
<li>few issue occured when experimenting file format converting, modified <code>02_cleanData.py</code> to address the issue.</li>
<li><h2 id="will-fix-more-tomorrow-check-1210604" class="anchored">will fix more tomorrow, check 121/0604</h2>
2025/06/10:</li>
<li>fix <code>06_gridMaker.py</code> wrong logic</li>
<li>fixed <code>02_cleanData.py</code>: improved filtering logic.</li>
<li>debug log shows that these profiles are having issues. These profiles are not included in the gridded dataset:</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 56%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>ITP Number &nbsp;Profile Number</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>itp114cormat</td>
<td>Abnormal profile measurement around 450 m</td>
</tr>
<tr class="even">
<td>itp115cormat</td>
<td>Contains only measurement from 575 m to 750 m</td>
</tr>
<tr class="odd">
<td>itp115cormat,0564,0582,0589,0593</td>
<td>Abnormal depth measurement</td>
</tr>
<tr class="even">
<td>itp32cormat</td>
<td>Abnormal depth measurement</td>
</tr>
<tr class="odd">
<td>itp1cormat</td>
<td>Contains only measurement at around 700 m</td>
</tr>
<tr class="even">
<td>itp21cormat</td>
<td>Contains only measurement from 500 m to 750 m</td>
</tr>
<tr class="odd">
<td>itp21cormat</td>
<td>Contains only measurement from 400 m to 450 m</td>
</tr>
<tr class="even">
<td>itp21cormat</td>
<td>Contains only measurement from 582.5 m to 602.5 m</td>
</tr>
<tr class="odd">
<td>itp21cormat</td>
<td>Contains only measurement from 387.5 m to 407.5 m</td>
</tr>
<tr class="even">
<td>itp3cormat</td>
<td>Contains only measurement from 675 m to 710 m</td>
</tr>
<tr class="odd">
<td>itp3cormat</td>
<td>Contains only measurement from 580 m to 680 m</td>
</tr>
<tr class="even">
<td>itp3cormat</td>
<td>Contains only measurement from 640 m to 740 m</td>
</tr>
<tr class="odd">
<td>itp5cormat</td>
<td>Contains only measurement from 450 m to 750 m</td>
</tr>
<tr class="even">
<td>itp5cormat</td>
<td>Contains only measurement from 575 m to 750 m</td>
</tr>
<tr class="odd">
<td>itp8cormat</td>
<td>Contains only measurement from 600 m to 700 m</td>
</tr>
<tr class="even">
<td>itp8cormat</td>
<td>Contains only measurement from 640 m to 710 m</td>
</tr>
<tr class="odd">
<td>itp8cormat</td>
<td>Contains only measurement from 680 m to 750 m</td>
</tr>
</tbody>
</table>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">2025/06/12: - added <code>StaircaseAlgorithm.py</code> for reference. Will start toy analysis algorithm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2025/06/16: - files in <code>gridDataMat</code> can only be loaded with <code>loadmat</code> function. - <code>09_test_tag.py</code> reproduces staircaseAlgorithm with minor changes</td>
</tr>
</tbody>
</table>
<p>2025/06/17: - The algorothm would be a time series analysis with SHAP analysis on the feature importance. —————————- 2025/06/18: - <code>09_test_tag.py</code> will now make a dataframe for time series analysis —————————— 2025/06/23: - <code>09_test_tag.py</code> makes transect plot for specific values, but unclear on how to skip nan value (How does nan get in there??) ——————————- 2025/07/02: - <code>04_Plot.py</code> now makes the transect plots. - <code>09_test_tag.py</code> would apply a time series analysis of logistic regression on ITP 62, 65 and 68 with metrics. ROC/AUC is needed, other metrics too ——————————- 2025/07/03: - renamed 09 script, took out machine learning part, and put it in <code>10_machineLearning.py</code> - The algorithm has very low precision on positive values, which is a problem. changing the positive class weight to 10 raised the precision from 0.06 to 0.22, imporoved recall and f1-score from 0 to 0.72 and 0.34 - keep raising the weight might reduce the precision, weight of 10 is good enough - ROC curve shows that the current performance (with weighted class) is not as good as expected. To raise the TPR to 80%, the false positive rate would have to be raised to beyond 20% ——————————— 2025/07/28: Steps of running everything to make plots: - 01 - 02 - 06 - 05 - 12 - 13 - 14 - 15 - 04 ——————————— 2025/07/29:</p>
<p>Might as well start cleaning up the work: List of cleaned and documented scripts <code>01_pullData.py</code> cleaned and documented <code>02_cleanData.py</code> cleaned and documented <code>06_gridMaker.py</code> cleaned and documented, changed to <code>03_gridMaker.py</code> <code>05_analyze.py</code> cleaned and documented, changed to <code>04_backgroundCalculation.py</code> <code>16_presPlot.py</code> cleaned and documented, changed to <code>05_presentPlots.py</code> ————————— 2025/09/15: Possible improvements: - a data inspector for user to check distribution and some rough-level feature of the dataset - a classfier for identifying staircases - customizable functions for user in: - obtaining the data - cleaning the data - processing the data - a good visualizer for better UI</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>